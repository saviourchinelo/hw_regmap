# This is a sample example of register-map definition

description="Hpu top-level register interface. Used by the host to retrieved RTL information, configure it and issue commands."
word_size_b = 32
offset = 0x00

# =====================================================================================================================
[section.Xrt]
description="Vitis Required registers"
offset= 0x0
align_offset=true

 # Currently not in used -> Placeholder only
[section.Xrt.register.reserved]
  description="Xrt reserved"
  default_val=0x00
  owner="User"
  read_access="Read"
  write_access="None"

# =====================================================================================================================
[section.Info]
description="Contain all the RTL parameters used that have impact on associated SW"
offset= 0x10
align_offset=true

[section.Info.register.Version]
  description="RTL version"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  param_name="VERSION"

[section.Info.register.NttInternal]
  description="Ntt internal parameters"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  field.radix = { size_b=8, offset_b=0 , default_value=2 , description="Ntt radix"}
  field.psi   = { size_b=8, offset_b=8 , default_value=16, description="Ntt Psi"}
  field.div   = { size_b=8, offset_b=16, default_value=0 , description="Ntt backward div"}
  field.delta = { size_b=8, offset_b=24, default_value=0 , description="Ntt network delta"}

[section.Info.register.NttArch]
  description="Ntt architecture"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  param_name="NTT_CORE_ARCH"

[section.Info.register.NttPbsNb]
  description="Maximum number of PBS in the Ntt pipeline"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  param_name="BATCH_PBS_NB"

[section.Info.register.NttModulo]
  description="Code associated with the prime number used in Ntt"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  param_name="MOD_NTT_NAME"

[section.Info.register.KsShape]
  description="Shape of Keyswitch computation kernel"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  field.x = { size_b=8, offset_b=0 , param_name="LBX", description="Nb coef. on X dim"}
  field.y = { size_b=8, offset_b=8 , param_name="LBY", description="Nb coef. on Y dim"}
  field.z = { size_b=8, offset_b=16, param_name="LBZ", description="Nb coef. on Z dim"}

[section.Info.register.KsInfo]
  description="Properties of Keyswitch computation kernel"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  field.mod_ksk_w = { size_b=8, offset_b=0 , param_name="MOD_KSK_W", description="Width of ksk modulo"}
  field.ks_l      = { size_b=8, offset_b=8 , param_name="KS_L", description="Nb of ks level"}
  field.ks_b      = { size_b=8, offset_b=16, param_name="KS_B_W", description="Width of ks decomp"}

[section.Info.register.HbmPc]
  description="HBM pseudo channel properties"
  owner="Parameter"
  read_access="Read"
  write_access="None"
  field.bsk_pc     = { size_b=8, offset_b=0 , param_name="BSK_PC", description="Bsk pc"}
  field.bsk_cut_nb = { size_b=8, offset_b=8 , param_name="BSK_CUT_NB", description="Bsk cut nb"}
  field.ksk_pc     = { size_b=8, offset_b=16, param_name="KSK_PC", description="Ksk pc"}
  field.ksk_cut_nb = { size_b=8, offset_b=24, param_name="KSK_CUT_NB", description="Ksk cut nb"}

# # =====================================================================================================================
# [section.LdSt]
# description="Define some properties of CT buffers in board-memory"
# align_offset=true
# duplicate=["_bank1","_bank2","_bank3","_bank4"]
# [section.LdSt.register.addr]
#   description="Ciphertext buffer addr"
#   owner="User"
#   read_access="Read"
#   write_access="Write"
#   duplicate=["_msb", "_lsb"]

#   # =====================================================================================================================
# [section.Keys]
# description="Define keys location properties"
# align_offset=true
# duplicate=["_Bsk", "_Ksk"]

# [section.Keys.register.addr_pc]
#   description="Key address for PC#"
#   owner="User"
#   read_access="Read"
#   write_access="Write"
#   duplicate=["_pc0_msb", "_pc0_lsb", "_pc1_msb", "_pc1_lsb", "_pc2_msb", "_pc2_lsb", "_pc3_msb", "_pc3_lsb"]

# [section.Keys.register.avail]
#   description="Key available bit"
#   owner="User"
#   read_access="Read"
#   write_access="Write"

# [section.Keys.register.reset]
#   description="Key reset sequence"
#   owner="Kernel"
#   read_access="Read"
#   write_access="WriteAction"

# # =====================================================================================================================
# [section.WorkAck]
# description="Purpose of this section"
# offset= 0x800
# align_offset=true

# [section.WorkAck.register.workq]
#   description="Insert work in workq and read status"
#   owner="Kernel"
#   read_access="Read"
#   write_access="WriteAction"

# [section.WorkAck.register.ackq_cmd]
#   description="Pop ack from in ackq"
#   owner="Kernel"
#   read_access="Read"
#   write_access="None"

# [section.WorkAck.register.ackq_status]
#   description="Status of ackq"
#   owner="Kernel"
#   read_access="Read"
#   write_access="None"

# # =====================================================================================================================
# [section.Stats]
# description="Contains all runtimes informations exposed by the RTL"
# offset= 0x1000
# align_offset=true

# [section.Stats.register.Dummy]
#   description="Dummy register"
#   default_val=0xdeadc0de
#   owner="User"
#   read_access="Read"
#   write_access="WriteNotify"
